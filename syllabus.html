<!DOCTYPE html>
<html>
    <head>

    </head>
    <body>
        <h2>
          ======================XXX-SYLABUSS-XXX=======================
===========PRACICE===========
START-PATTERN         -   MONDAY
ARRAY                 -21 TUESDAY
SEARCHING             -15 WEDNESDAY
TWO POINTERS          -19 THRUSDAY    
STRING                -22 FRIDAY



===========PRACICE===========
ARRAY-
Dynamic and static array.
Memory Allocation - Access and storage


MULTI- DIMENTIONAL (ARRAY)-
Access
Metrics


OPERATIONS-
Insertion, deletion - End, start, middle 
Traversal - Forward and Backward
Maximum number
Minimum number

MANUPULATION-
Reverse,	
Rotate, 	- No
Shuffle,	- No
Randomisation	- No


PATTERNS-
Two pointer
Sliding window technique

Sub Array
Hash Table


SEARCHING AND SORTING-
Liner Search 
Binary Search

Bubble Sort
Inseartion Sort
Quick Sort
Merge Sort

LeetCode- Mostly Easy , Some Medium

==============XXX==============


STRING-
(Upto how many types we can iterate or concat)
Indexing, 
Iteration, 
Concatenation,  
Substring extraction, 
Trimming, 
Splitting, 
Joining, 
Case conversion, 
Replacing characters,
Reverse,
Anagram, 
Palindrom

==============XXX==============



================================================================

DSA POINTS TO REMEMBER-

========
1. IN DSA REVISION IS THE KEY (NO MAGIC SOLUTION),
2. FIRST BUILD FOUNDATION - Basic Manipulation and some Patterns Only after CP.
3. DON'T GO MINDLESSLY TO SOLVE LEETCODE QUESTIONS- Understand Some Patterns of solving questions and 
pickup and revise it daily. Because solving 200 questions will also not help after that.
4. IN LEETCODE PROBLEMS ARE SAME BUT PATTERNS ARE LITTLE DIFFERENT. SO Understand Patterns.

========

========
PATTERN QUESTIONS-
First step- Take input (upto where we wants to run).
     
Last Step- what to print.
After code written explain the code flow that how it will going to work. 

In Pattern we have to print either i, j , "*" , i+1, j+1, these are confirm

Sometimes we have to use formula approach in print patterns.
Try to create your own formula to create formula it uses only i, j, +1, -1, value+1 


// First think about the approach or visualise the approach.

// Understand the flow of loop question.
// Time limit and optimised solution is more important.

// By heart the best approach.
// Two pointer approach is more used and most asked question in interview 
========

========
Try to solve the solution on pen and paper

Mark every problem into Easy , Medium and Hard Then check in which level you are facing problems

Do 20-25 Questions of each Topic. Easy - 12.  Medium- 8. Hard- 5.  

Be consistent- (1-2 Day of break will forget you everything)- Give Topic wise break. Change topics every week else.

3 Phases of solving problem-

1. Solved in 1-2 Approach.

2. Solved in 4-5 Approach.

3. Problem Unsolved- (Here we are building logics and understand more give more time) Then solve it after 
a week if you remember the logic and able to do then fine otherwise repeat it after 1 week.


==============================================

=========================|| Questions ||============================
ARRAY- (LOVE BABBAR SHEET)


=============|| EASY ||=============

1. Reverse the array. (ARRAY) - DONE                                    - (EASY)
	
2. Find the maximum and minimum element in an array.                    - (EASY)  

3. Find the "Kth" max and min element of an array. (HEAP) -             - (EASY)            NA

4. Given an array which consists of only 0, 1 and 2. Sort the array without using any sorting algo. 	- (EASY) GFG 

5. Move all the negative elements to one side of the array.             - (EASY) (POINTER)

6. Find the Union and Intersection of the two sorted arrays.            - (EASY) (POINTER)           

7. Write a program to cyclically rotate an array by one. -              - (EASY)

9. Minimise the maximum difference between heights                      - (EASY) [V.IMP]

12. Merge 2 sorted arrays without using Extra space.                    - (EASY) GFG    (REPEATE)

Best time to buy and Sell stock                                         - (EASY)        (REPEATE)

17 find all pairs on integer array whose sum is equal to given number   - (EASY)

18 find common elements In 3 sorted arrays                              - (EASY)

20 Find if there is any subarray with sum equal to 0                    - (EASY)

26 Find whether an array is a subset of another array                   - (EASY) GTG

28 Trapping Rain water problem                                          - (EASY) GFG          NA

31 Three way partitioning of an array around a given value              - (EASY) GFG SORTED ARRAY 

=============|| EASY ||=============

=============|| MEDIUM ||=============

10. Minimum no. of Jumps to reach end of an array. -                    - (MEDIUM) GFG SORTED ARRAY 

11. 287.find duplicate in an array of N+1 Integers                      - (MEDIUM)

13. Largest Sum Contiguous Subarray. Kadane's Algo                      - (MEDIUM) GFG [V.V.V.V.V IMP]

14. 56.Merge Intervals                                                  - (MEDIUM)  (REPEATE)

15. Next Permutation                                                    - (MEDIUM)  (REPEATE)

16. Count Inversion                                                     - (MEDIUM) (GOOGLE,ADOBE,AMAZON)

19 Rearrange the array in alternating positive and negative items with O(1) extra space    - (MEDIUM) GFG 

21 Find factorial of a large number                                     - (MEDIUM) (TSC, MICROSOFT)

22 find maximum product subarray                                        - (MEDIUM)

23 Find longest consecutive subsequence                                 - (MEDIUM) GFG 

24 Given an array of size n and a number k, find all elements that appear more than " n/k " times.  - (MEDIUM) GFG 

27 Find the triplet that sum to a given value                           - (MEDIUM) GFG 

29 Chocolate Distribution problem                                       - (MEDIUM) GFG 

30 Smallest Subarray with sum greater than a given value                - (MEDIUM) GFG 

32 Minimum swaps required bring elements less equal K together          - (MEDIUM) GFG SORTED ARRAY 

33 Minimum no. of operations required to make an array palindrome       - (MEDIUM) GFG SORTED ARRAY 

34 Median of 2 sorted arrays of equal size                              - (MEDIUM) GFG SORTED ARRAY 

35.Median of 2 sorted arrays of different size.                         - (MEDIUM) GFG SORTED ARRAY 

=============|| MEDIUM ||=============

=============|| HARD ||=============

25 Maximum profit by buying and selling a share atmost twice            - (HARD) GFG 

=============|| HARD ||=============

*************************************************************************************************************

ARRAY- (STRIVERS DSA SHEET)

=============|| EASY ||=============

53. Maximum Subarray                                                    - (EASY)

121. Best Time to Buy and Sell Stock                                    - (EASY)   (REPEATE)

88. Merge Sorted Array                                                  - (EASY)   (REPEATE)

169. Majority Element                                                   - (EASY)

1. Two Sum                                                              - (EASY)

=============|| EASY ||=============


=============|| MEDIUM ||=============

73. Set Matrix Zeroes                                                   - (MEDIUM)

118. Pascal's Triangle                                                  - (MEDIUM)

31. Next Permutation                                                    - (MEDIUM)  (REPEATE)

75. Sort Colors                                                         - (MEDIUM)

128. Longest Consecutive Sequence                                       - (MEDIUM)  (REPEATE)

Largest subarray with 0 sum                                             - (MEDIUM)

48. Rotate Image                                                        - (MEDIUM)

56. Merge Intervals                                                     - (MEDIUM)  (REPEATE)

74. Search a 2D Matrix                                                  - (MEDIUM)

50. Pow(x, n)                                                           - (MEDIUM)

229. Majority Element II                                                - (MEDIUM)

62. Unique Paths                                                        - (MEDIUM)

287. Find the Duplicate Number                                          - (MEDIUM)


=============|| MEDIUM ||=============

Repeat and Missing Number Array                                         - (HARD)

Inversion of Array (Pre-req: Merge Sort)                                - (HARD)

493. Reverse Pairs                                                      - (HARD)

18. 4Sum                                                                - (MEDIUM & HARD)

Count number of subarrays with given xor K                              - (HARD)


=========================|| Questions ||============================

TWO POINTERS & SLIDING WINDOW - (STRIVERS DSA SHEET)

LINK- https://www.youtube.com/playlist?list=PLgUwDviBIf0q7vrFA_HEWcqRqMpCXzYAL
(ADITYA VERMA) LINK- https://www.youtube.com/playlist?list=PL_z_8CaSLPWeM8BDJmIYDaoQ5zuwyxnfj

1. 1423. Maximum Points You Can Obtain from Cards                          - (MEDIUM)       NA

2. 3. Longest Substring Without Repeating Characters                       - (MEDIUM)

3. 1004. Max Consecutive Ones III                                          - (MEDIUM)

4. 904. Fruit Into Baskets                                                 - (MEDIUM)  

5. Longest K unique characters substring                                   - (MEDIUM)         NA

6. 1358. Number of Substrings Containing All Three Characters              - (MEDIUM)

7. 424. Longest Repeating Character Replacement                            - (MEDIUM)         NA

8. 930. Binary Subarrays With Sum                                          - (MEDIUM)

9. 1248. Count Number of Nice Subarrays                                    - (MEDIUM)         NA

10. 992. Subarrays with K Different Integers                               - (HARD)           NA

11. Find Largest sum contiguous Subarray                                   - (MEDIUM) [V. IMP](POINTER)

12. 76. Minimum Window Substring                                           - (HARD)



=========================|| QUESTIONS ||===========================

STRING - (LOVE BABBAR DSA SHEET)

1. Reverse a String                                                     - (EASY)  - DONE
	
2. Check whether a String is Palindrome or not                          - (EASY)  - DONE

3. Find Duplicate characters in a string                                - (EASY)  - DONE
	
4. Write a Code to check whether one string is a rotation of another    - (EASY)  - DONE
	
5. Write a Program to check whether a string is a valid shuffle of two strings or not     - (MEDIUM)  -DONE

6. Count and Say problem                                                                  - (MEDIUM)  -DONE

7. Write a program to find the longest Palindrome in a string.[ Longest palindromic Substring]

8. Find Longest Recurring Subsequence in String

9. Print all Subsequences of a string.

10. Print all the permutations of the given string

11. Split the Binary string into two substring with equal 0’s and 1’s                 - (EASY) DONE

12. Word Wrap Problem [VERY IMP].

13. EDIT Distance [Very Imp]

14. Find next greater number with same set of digits. [Very Very IMP]

15. Balanced Parenthesis problem.[Imp]

16. Word break Problem[ Very Imp]                                                 - (HARD)    NA

17. Rabin Karp Algo                                                               - (MEDIUM) NA

18. KMP Algo                                                                      - (MEDIUM)  NA

19. Convert a Sentence into its equivalent mobile numeric keypad sequence.        - (EASY)  - DONE

20. Minimum number of bracket reversals needed to make an expression balanced.      - (EASY)   NA

21. Count All Palindromic Subsequence in a given String.                            - NA

22. Count of number of given string in 2D character array

23. Search a Word in a 2D Grid of characters.

24. Boyer Moore Algorithm for Pattern Searching.                               - (MEDIUM) NA

25. Converting Roman Numerals to Decimal                                       - (EASY) (REPEATE)

26. Longest Common Prefix

27. Number of flips to make binary string alternate

28. Find the first repeated word in string.                                     - (EASY) - DONE

29. Minimum number of swaps for bracket balancing.

30. Find the longest common subsequence between two strings.

31. Program to generate all possible valid IP addresses from given string.

32. Write a program to find the smallest window that contains all characters of string itself.

33. Rearrange characters in a string such that no two adjacent are same

34. Minimum characters to be added at front to make string palindrome

35. Given a sequence of words, print all anagrams together

36. Find the smallest window in a string containing all characters of another string

37. Recursively remove all adjacent duplicates

38. String matching where one string contains wildcard characters

39. Function to find Number of customers who could not get a computer

40. Transform One String to Another using Minimum Number of Given Operation

41. Check if two given strings are isomorphic to each other

42. Recursively print all sentences that can be formed from list of word lists




STRING - (STRIVERS DSA SHEET)

1. 13. Roman to Integer                                                      - (EASY)       - DONE

2. 28. Find the Index of the First Occurrence in a String                    - (EASY)       - DONE

3. 242. Valid Anagram                                                        - (EASY)       - DONE

4. 14. Longest Common Prefix                                                 - (EASY)       - DONE

5. 165. Compare Version Numbers                                              - (MEDIUM)     - DONE

6. 151. Reverse Words in a String                                            - (MEDIUM) (REPEATE)     - DONE

7. 5. Longest Palindromic Substring                                          - (MEDIUM)

8. 8. String to Integer (atoi)                                               - (MEDIUM)

9. 38. Count and Say                                                         - (MEDIUM)

10. Rabin-Karp algorithm C++ implementation                                  - (HARD)     - (REPEATE)

11. Minimum characters needed to be inserted in the beginning to make it palindromic    - (HARD)


=========================|| Questions ||============================

BINARY SEARCH - (LOVE BABBAR DSA SHEET)

1. Search 33 start and end index                                          - (EASY)  -DONE

2. 69. SQRT-                                                              - (EASY)  -DONE

3. Get Pivot Element from a sorted and rotated array.                     - (EASY)  -DONE

12. Square root of an integer                                             - (EASY)  -DONE

13. Find the repeating and the missing                                    - (EASY) - DONE

14. Find majority element                                                 - (EASY) - DONE

10. Find a Fixed Point (Value equal to index) in a given array            - (EASY)  -DONE

4. 3159 Search total count of 44 in an array                              - (MEDIUM)  -DONE

5. Find a peak element which is not smaller than its neighbours           - (MEDIUM)  -DONE

9. 34. Find first and last positions of an element in a sorted array      - (MEDIUM)  -DONE

11. Search in a rotated sorted array                                      - (MEDIUM) (REPEATE) -DONE                                      

15. Find a pair with a given difference                                   - (EASY)  -DONE

16. Find four elements that sum to a given value

17. K-th Element of Two Sorted Arrays                                     - (MEDIUM)  - NOT OPTIMAL

18. EKOSPOJ

19. Smallest number with at least n trailing zeroes in factorial          - (MEDIUM)   NA  

20. ROTI-Prata SPOJ

21. DoubleHelix SPOJ

22. Find the inversion count                                              - (MEDIUM)   NA 

23. Implement Merge-sort in-place                                         - (MEDIUM)   NA 

6. Book Allocation                                                        - (HARD) (REPEATE)                    

7. Agressive Cow                                                          - (HARD) (REPEATE)                  

8. Painters Partitation                                                   - (HARD) (REPEATE)    




BINARY SEARCH - (STRIVERS DSA SHEET)

1. Find Nth Root Of M                                                      - (EASY)         -DONE

2. Median in a row-wise sorted Matrix                                      - (HARD)

3. 540. Single Element in a Sorted Array.                                  - (MEDIUM)       -DONE   

4. 33. Search in Rotated Sorted Array                                      - (MEDIUM) (REPEATE) -DONE

5. 4. Median of Two Sorted Arrays                                          - (HARD)

6. K-th element of two Arrays                                              - (MEDIUM)       -NOT OPTIMAL

7. Aggressive Cow                                                          - (HARD) (REPEATE)                 



=========================|| Questions ||============================

SORTING - (LOVE BABBAR DSA SHEET)

NOTE- Insertion Sort, Bubble Sort, and Selection Sort are often used for educational purposes and
small datasets due to their simplicity. However, they are not typically used in competitive programming
or interviews because of their less optimal time complexities (O(n^2)). Despite this, they can be applied to 
specific scenarios where their properties might be advantageous or when the dataset is small. Here are some 
scenarios or specific types of problems where these algorithms might be applied:

MOSTLY- MERGE AND QUICK SORT IS USED IN COMPETITIVE PROGRAMMING-

1. Find first and last positions of an element in a sorted array

2. Find a Fixed Point (Value equal to index) in a given array

3. Find the repeating and the missing

4. Find majority element

5. Count triplets with sum smaller than a given value

6. Merge 2 sorted arrays

7. Product array Puzzle

8. Sort array according to count of set bits

9. Minimum no. of swaps required to sort the array

10. Bishu and Soldiers

11. Rasta and Kheshtak

12. Kth smallest number again

13. Find pivot element in a sorted array

14. K-th Element of Two Sorted Arrays

15. Job Scheduling Algo

16. Missing Number in AP

17. Smallest number with at least n trailing zeroes in factorial

18. ROTI-Prata SPOJ

19. Subset Sums

20. Find the inversion count

21. Implement Merge-sort in-place

22. Partitioning and Sorting Arrays with Many Repeated Entries

=========================|| Questions ||============================


===================================================

TOPIC- JAVASCRIPT MEMORY ALLOCATION-
1. Stack(Premitive Data types) - It make copy
2. Heap(Non-Primitive Data Types) - It makes references

Both Accessing and Managing are different.

===================================================

TOPIC- OPTIONAL CHAINING-
let user= {name:"Ronak"}

user.firstName   	// Error  It will break the program so save the tp show error use 

user?.firstName		// undefined.  It will show undefined rather than error

user?.firstName ?? "Hello" // Hello If Left key is not present the show by default "Hello" 
This is called nullish chaning something.
 
===================================================

TOPIC- DYNAMIC ARRAY & STATIC ARRAY

Dynamic Arrays in JavaScript
Characteristics:

Resizable: Dynamic arrays can grow or shrink as needed. You don't have to define the size when you create the array.
Flexible Memory Allocation: Memory is allocated as needed when elements are added or removed.
Convenience: Many built-in methods are available to manipulate arrays, such as push, pop, shift, unshift, and splice.

EXAMPLE-

let dynamicArray = [];    // Create a dynamic array

dynamicArray.push(1);     // Add elements
dynamicArray.push(2);
dynamicArray.push(3);

console.log(dynamicArray); // [1, 2, 3]

dynamicArray.pop();       // Remove the last element
console.log(dynamicArray); // [1, 2]


Advantages:

Flexibility: You can easily adjust the array size at runtime.
Ease of Use: JavaScript provides many methods to manipulate dynamic arrays.
No Size Declaration: There's no need to specify the size upfront.




STATIC ARRAY (Conceptual in JavaScript)-

JavaScript does not have true static arrays where the size is fixed at compile-time. However, we can simulate static arrays by fixing the size and avoiding resizing.

Characteristics:

Fixed Size: Once created, the size cannot be changed.
Pre-allocated Memory: Memory is allocated based on the fixed size at the time of creation.

EXAMPLE-

let staticArray = new Array(3);  // Create an array with a fixed size

staticArray[0] = 1;  // Assign values
staticArray[1] = 2;
staticArray[2] = 3;

console.log(staticArray); // [1, 2, 3]

// Attempting to resize (conceptually static, should avoid this)
staticArray.push(4); // This is possible in JavaScript but would be avoided for static array simulation
console.log(staticArray); // [1, 2, 3, 4] - Shows the array can still be resized in JavaScript


Advantages:

Predictable Memory Usage: Memory allocation is known upfront, which can lead to predictable performance.
Performance: Fixed size arrays can be more performant in scenarios where the size does not change.
Disadvantages:

Inflexibility: Cannot change size once set; not suitable for scenarios where the data size is variable.
Not Natively Supported: JavaScript does not enforce static array size, so the concept must be self-imposed.


COMPARASION-
Feature		Dynamic Arrays				Static Arrays 
Size		Flexible, resizable			Fixed at creation, not resizable
Memory Allo.	Dynamic, as needed			Fixed, pre-allocated
Ease of Use	High, many built-in methods available	Lower, requires careful management
Performance	Potential overhead from resizing	More predictable, but limited use cases
Flexibility	Very flexible				Rigid, not suitable for variable data

Summary-
In JavaScript, arrays are inherently dynamic, offering great flexibility and ease of use for most applications. The concept of static arrays, while not natively supported, can be simulated by fixing the array size and avoiding operations that change its size. This conceptual understanding can help in scenarios where predictable performance and memory usage are critical.

===================================================

TOPIC- METRICS-

"Metrics" often refers to various measurements or calculations performed on the array to derive meaningful insights or to facilitate certain operations.

1. Length
The most basic metric, the length of an array, tells you how many elements are in the array.

let array = [1, 2, 3, 4, 5];
console.log(array.length); // Output: 5


2. Sum

3. Average

4. Maximum and Minimum Values
Finding the maximum and minimum values in an array.

let array = [1, 2, 3, 4, 5];
let max = Math.max(...array);
let min = Math.min(...array);
console.log(max); // Output: 5
console.log(min); // Output: 1


5. Range
The range of an array, defined as the difference between the maximum and minimum values.

javascript
Copy code
let array = [1, 2, 3, 4, 5];
let range = Math.max(...array) - Math.min(...array);
console.log(range); // Output: 4


6. Median


7. Mode


8. Unique Elements
Finding unique elements in an array.

let array = [1, 2, 2, 3, 4, 4, 5];
let uniqueArray = [...new Set(array)];
console.log(uniqueArray); // Output: [1, 2, 3, 4, 5]

===================================================

TOPIC- ACCESSING OF ARRAY

Accessing arrays in JavaScript involves various methods to retrieve, modify, or interact with elements in an array.


1. Accessing Elements by Index
You can access elements in an array using their index, starting from 0.

let array = [10, 20, 30, 40, 50];

console.log(array[0]); // Output: 10
console.log(array[2]); // Output: 30
console.log(array[array.length - 1]); // Output: 50 (last element)



2. Modifying Elements by Index
You can modify elements in an array by assigning new values to specific indices.

let array = [10, 20, 30, 40, 50];

array[1] = 25; // Modify the second element
console.log(array); // Output: [10, 25, 30, 40, 50]



3. Adding Elements
Using push Method
The push method adds one or more elements to the end of an array.

let array = [10, 20, 30];
array.push(40, 50);
console.log(array); // Output: [10, 20, 30, 40, 50]
Using unshift Method
The unshift method adds one or more elements to the beginning of an array.

let array = [10, 20, 30];
array.unshift(0, 5);
console.log(array); // Output: [0, 5, 10, 20, 30]


4. Removing Elements
Using pop Method
The pop method removes the last element from an array.

let array = [10, 20, 30];
array.pop();
console.log(array); // Output: [10, 20]
Using shift Method
The shift method removes the first element from an array.


let array = [10, 20, 30];
array.shift();
console.log(array); // Output: [20, 30]



5. Iterating Over Arrays
Using for Loop
javascript
Copy code
let array = [10, 20, 30];

for (let i = 0; i < array.length; i++) {
  console.log(array[i]);
}



6. Finding Elements
Using indexOf Method
The indexOf method returns the first index at which a given element can be found in the array, or -1 if it is not present.

let array = [10, 20, 30, 40, 50];
let index = array.indexOf(30);
console.log(index); // Output: 2


=================================================

TOPIC- TRAVERSING FORWARD AND BACKWARD

FORWARD Traversal- (Using a for Loop)

let array = [10, 20, 30, 40, 50];

// Forward traversal using a for loop
for (let i = 0; i < array.length; i++) {
  console.log(array[i]);
}



BACKWARD Traversal-

let array = [10, 20, 30, 40, 50];

// Backward traversal using a for loop
for (let i = array.length - 1; i >= 0; i--) {
  console.log(array[i]);
}


===============================================

TOPIC- ARRAY OPERATIONS-  INSERTATION, DELETION AND MERGING IN ARRAY


// 1. Insert Element in Array     
let a =[11,22,33,44,55,66];
let el= 70;
let pos=2;

for(let i=a.length-1; i>=0; i--){      // a.length= it starts from 5 ( reverse ) | i>=0 => i will run 5 to 0 index. 
	// document.write(i)
 if(i>=pos){                          // i>=pos => i should be greater than pos which is 2 index.
	a[i+1]= a[i];				        // a[i+1] => a will create a extra space at index 2. | a[i] => after creating a space numbers will move forward. 
	 if(i==pos){		                // once the i is equal to pos then at that empty space el =70 will be placed.
	  	 a[i]=el;
	 }
 }  
 }  
document.write(a)




<h2>1. Insert Element in Array </h2>
<input type="number" id="pos" placeholder="Enter Position" />
<input type="number" id="el" placeholder="Enter Element" />
<button onclick="insert()">Insert</button>


function insert(){
let a =[11,22,33,44,55,66];
let el= document.getElementById('el').value;
let pos= document.getElementById('pos').value;

for(let i=a.length-1; i>=0; i--){        
 if(i>=pos){                              
	a[i+1]= a[i];				         
	 if(i==pos){		            	
		 a[i]=el;
	 }
}
}
document.write(a)

}





2. Delete Element in Array     

let a= [11,22,33,44,55,66,77];
let pos= 3;
for(let i=pos; i<a.length; i++){
	a[i]=a[i+1];           // [ 11, 22, 33, 55, 66, 77, undefined ] 
}
a.length= a.length-1;   // now fixing the length of the length 7 to 6 | a.length= 7  a.length-1 = 6. 
console.log(a);    





3. Merge 2 Arrays     

let a =[11,22,33,44,55,66];
let b= [77,88,99,100];
let c=[];

for(let i=0; i<a.length; i++){
	c[i]= a[i];      // Pushing the value of a value in c
}
// console.log(c);  [ 11, 22, 33, 44, 55, 66 ]

for (let i=0; i<b.length; i++){
	c[a.length+i]=b[i]      // a.length+i gives index number of b => 6 7 8 9  | so it means we have to put our b index value in a.length+1
}
console.log(c)

//Result- [ 11, 22, 33, 44, 55, 66, 77, 88, 99, 100 ]




================================================

TOPIC- DETAILS OF PATTERNS AND SEARCHING AND SORTING ALGORITHMS.

# SEARCHING ALGORITHIUM-
1. Linear Search

Simple and straightforward; useful for small arrays or unsorted arrays.
Time Complexity: O(n)

function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;
}



2. Binary Search
Binary Search is always applied on monotonic function (either an array is in increasing form of decreasing form).
Efficient for sorted arrays.
Time Complexity: O(log n)

function binarySearch(arr, target) {
  let left = 0, right = arr.length - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return -1;
}




# SORTING ALGORITHMS

1. Bubble Sort

Simple but inefficient for large arrays.
Time Complexity: O(n^2)

function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}



2. Insertion Sort

Efficient for small arrays or partially sorted arrays.
Time Complexity: O(n^2)

function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let key = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
  return arr;
}



3. Quick Sort

Efficient and commonly used sorting algorithm.
Time Complexity: O(n log n) on average, O(n^2) in the worst case

function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const right = arr.filter(x => x > pivot);
  const middle = arr.filter(x => x === pivot);
  return [...quickSort(left), ...middle, ...quickSort(right)];
}



4. Merge Sort

Efficient and stable sorting algorithm.
Time Complexity: O(n log n)

function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  return merge(left, right);
}

function merge(left, right) {
  let result = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  return result.concat(left, right);
}



# PATTERNS

1. Two Pointer Technique

Useful for problems involving pairs or subarrays, especially in sorted arrays.
Examples: finding pairs with a given sum, removing duplicates.

function twoSum(nums, target) {
  let left = 0, right = nums.length - 1;
  while (left < right) {
    const sum = nums[left] + nums[right];
    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  return [];
}


2. Sliding Window Technique

Useful for problems involving subarrays or substrings of fixed or variable lengths.
Examples: maximum sum subarray, longest substring without repeating characters.

function maxSumSubarray(arr, k) {
  let maxSum = 0, windowSum = 0;
  for (let i = 0; i < k; i++) {
    windowSum += arr[i];
  }
  maxSum = windowSum;
  for (let i = k; i < arr.length; i++) {
    windowSum += arr[i] - arr[i - k];
    maxSum = Math.max(maxSum, windowSum);
  }
  return maxSum;
}

Sliding window Technique-

https://www.youtube.com/watch?v=EHCGAZBbB88&list=PL_z_8CaSLPWeM8BDJmIYDaoQ5zuwyxnfj

-How to identify where to implement.
Given window size, sub array, maximum or minimum , or K=3  given, Just think once can we apply
Sliding window technique.


There are 2 types- Fix(easy)   variable(little bit hard)




#. Additional Topics to Consider
To be well-prepared for a wide range of array problems on LeetCode, consider exploring the following additional topics:

1. Prefix Sum

Useful for range sum queries and subarray problems.

function prefixSum(arr) {
  let prefix = [0];
  for (let i = 0; i < arr.length; i++) {
    prefix.push(prefix[i] + arr[i]);
  }
  return prefix;
}




2. Greedy Algorithms

Useful for optimization problems where locally optimal choices lead to a global solution.
Examples: interval scheduling, jump game.
javascript
Copy code
function canJump(nums) {
  let maxReach = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i > maxReach) return false;
    maxReach = Math.max(maxReach, i + nums[i]);
  }
  return true;
}




3. Backtracking

Useful for problems involving permutations, combinations, and subsets.

function subsets(nums) {
  let result = [];
  function backtrack(start, path) {
    result.push([...path]);
    for (let i = start; i < nums.length; i++) {
      path.push(nums[i]);
      backtrack(i + 1, path);
      path.pop();
    }
  }
  backtrack(0, []);
  return result;
}



4. Dynamic Programming

Useful for problems involving optimization and subproblems with overlapping subproblems.
Examples: longest increasing subsequence, maximum subarray sum.

function lengthOfLIS(nums) {
  if (nums.length === 0) return 0;
  let dp = new Array(nums.length).fill(1);
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  return Math.max(...dp);
}



By mastering these topics, you'll be well-equipped to tackle a wide range of array problems on LeetCode.


================================================


        </h2>
    </body>
</html>